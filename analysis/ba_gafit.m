function [DataOut, ga_summary] = ba_gafit(dftable, plotTF)
% BA_GAFIT fits adhesion force data using genetic algorithm
% 
% This function fits the collected detachment forces for a bead:substrate
% surface interaction to the project's standard form (modified erf). It
% uses a genetic algortihm for glocal optimization (agnostic fitting) and 
% avoids most (all?) local minima for the default settings saved here. 
% After the ga fits are optimized, a bootstrapping simluation is done to 
% estimate the uncertainty  in the model's fit parameters.
%
%   [DataOut, ga_summary] = ba_gafit(dftable, plotTF)
%
% Outputs:
%   DataOut is the output table containing fit parameters and metadata
%   ga_summary provides metadata for the ga fitting process itself
%
% Inputs: 
%   dftable is the "DetachForce" table from the outpyut "B" structure
%           generated by ba_process_expt
%   plotTF  is a switch for generating visual/debug output during a fitting
%           run.
%

% Global optimization fitting routine for Adhesion Assay using the
% genetic algorithm. This algorithm serves as a good choice over 
% the particleswarm because it allows for fitting with constraints. It is
% painfully slow, though.
%
if nargin < 2 || isempty(plotTF)
    plotTF = false;
end

DataOut = dftable;

% for plotting
stdclr = lines(7);



% Some number (m) of plates to process
for m = 1:height(DataOut)

    if plotTF
        ga_opts.PlotFcn = {'gaplotscores','gaplotbestlogf'};
    end

    PlateID = DataOut.PlateID(m);
    rawdata = DataOut.RawData{m};
    
    logforce_nN = log10(rawdata.Force);
    logforceinterval = log10(rawdata.ForceInterval);
    fractionLeft = rawdata.FractionLeft; 
    weights = rawdata.Weights; %     weights = ba_weights(rawdata.ForceInterval, 0.95, 'quantile', 4);

    Ns = numel(logforce_nN); % Ns = number of samples

    ga_opts = DataOut.gaOpts(m);
    fout = DataOut.gaFitSetup(m);
    

    % set up the earlier run if there is one...
    if isTableCol(DataOut, 'FinalPop') && ~isempty(DataOut.FinalPop) 
        oldp = DataOut.FitParams{m};
        oldsse = DataOut.sse(m);

        oldpopmatrix = DataOut.FinalPop{m};
        oldscores = DataOut.FinalScore{m};

        [oldscores, idx] = sortrows(oldscores);
        oldpopmatrix = oldpopmatrix(idx,:);

        newpopmatrix = [oldp; oldpopmatrix(1:end-1,:)];
        newscores = [oldsse; oldscores(1:end-1,:)];
        ga_opts.InitialPopulationMatrix = newpopmatrix;
        ga_opts.InitialScoresMatrix = newscores;
    end

    % fout  = ba_fit_setup(Nmodes);


    rng("shuffle");
    rngState = rng;

    % Call the global optimizer [x,fval,exitflag,output,population,scores] 
    tic 
    try
        [optimized_params, error, exitflag, output, finalpop, finalscore] = ga(@(p) objectiveFunction(p, fout.fcn, logforce_nN, fractionLeft, weights), ...
                                    fout.Nparams, fout.Aineq, fout.bineq, [], [], fout.lb, fout.ub, [], ga_opts);
    catch
        warning('First time fitting this dataset failed. Trying again.');
        rng("shuffle");
        rngState = rng;

        [optimized_params, error, exitflag, output, finalpop, finalscore] = ga(@(p) objectiveFunction(p, fout.fcn, logforce_nN, fractionLeft, weights), ...
                                    fout.Nparams, fout.Aineq, fout.bineq, [], [], fout.lb, fout.ub, [], ga_opts);
    end
    t=toc;

    rchisq = red_chisquare(optimized_params, fout.fcn, logforce_nN, fractionLeft, weights);
    
    % Set up the output diagnostic/summary table for the run
    ga_summary = table(PlateID, t, {optimized_params}, error, rchisq, exitflag, ...
                       ga_opts.MaxGenerations, ga_opts.PopulationSize, ...
                       output.generations, {finalpop}, {finalscore}, fout, ga_opts, ...
                       'VariableNames', {'PlateID', 'SolveTime', 'OptimizedStartParameters', 'TotalError', 'RedChiSq', 'ExitFlag', ...
                                         'MaxGenerations', 'PopulationSize', ...
                                         'GenerationSolveCount', 'FinalPop', 'FinalScore', 'gaFitSetup', 'gaOpts'});
      
    cftbx_opts = ba_fitoptions('fit');    
    [StatT, BootstatT] = ba_bootstrap_fit(logforce_nN, fractionLeft, weights, fout, cftbx_opts);

    DataOut.FitParams(m) = StatT.p;
    DataOut.confFitParams(m) = StatT.pconf;
    DataOut.sse(m) = StatT.sse;
    DataOut.rsquare(m) = StatT.rsquare;
    DataOut.adjrsquare(m) = StatT.adjrsquare;
    DataOut.dfe(m) = StatT.dfe;
    DataOut.rmse(m) = StatT.rmse;
    DataOut.redchisq(m) = StatT.redchisq;
    % DataOut.BootFitSetup(m) 
    DataOut.BootFitOptions(m) = cftbx_opts;
    DataOut.BootstatT{m} = BootstatT;
    DataOut.FinalPop{m} = finalpop;
    DataOut.FinalScore{m} = finalscore;
    DataOut.gaFitSetup(m) = fout;
    DataOut.gaOpts(m) = ga_opts;

    % Assign new parameters to the (modified and then ultimately outputted) data table

    if plotTF                
        fig{m} = figure;
        hold on
           plot( logforce_nN, fractionLeft, 'Marker','o', 'MarkerSize', 3, 'MarkerEdgeColor',stdclr(1,:), 'MarkerFaceColor',stdclr(1,:), 'LineStyle','none');
           plot( logforceinterval(:,1), fractionLeft, 'Marker','>', 'MarkerSize', 2, 'MarkerEdgeColor',stdclr(1,:)*1.25, 'MarkerFaceColor','none', 'LineStyle','none');
           plot( logforceinterval(:,2), fractionLeft, 'Marker','<', 'MarkerSize', 2, 'MarkerEdgeColor',stdclr(1,:)*1.25, 'MarkerFaceColor','none', 'LineStyle','none');
           plot( logforce_nN, fout.fcn(optimized_params, logforce_nN), 'k-', 'LineWidth', 1); 
        hold off        
        xlabel('log_{10}(Force [nN])');
        ylabel('Fraction Left');
        title(string(PlateID), 'Interpreter','none');
        title(join(string(DataOut{m,{'PlateID', 'BeadChemistry', 'SubstrateChemistry', 'Media', 'pH'}}), ', '), 'Interpreter','none');
        fig{m}.Units = 'normalized';
        fig{m}.Position = [0.616 0.519 0.292 0.389];
        legend(['data', 'error', 'error', compose('%02.6d',error(:)')]);    
    end

end % end for-loop


end % end function


function error = objectiveFunction(params, fitfcn, logforce_nN, fractionLeft, weights)
    % params: Parameters to be optimized, [a am as bm bs]
    % xdata: Independent variable data
    % ydata: Dependent variable data
    % weights: Weight values for each data point


    % Calculate model predictions using params and xdata
    model_predictions = fitfcn(params, logforce_nN);

    % Calculate weighted squared error
    weighted_errors = weights .* (model_predictions - fractionLeft).^2;
%     weighted_errors = smooth(weighted_errors,5);
    error = sum(weighted_errors, [], 'omitnan');
end



